<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesium Earth with Satellite</title>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body, #cesiumContainer { width: 100%; height: 100%; overflow: hidden; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial; font-size: 18px; color: #fff; z-index: 1000; background: rgba(0, 0, 0, 0.7); padding: 20px 40px; border-radius: 8px; }
        .info { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: #fff; padding: 15px; border-radius: 8px; font-family: Arial; font-size: 14px; z-index: 1000; max-width: 320px; }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 8px; z-index: 1000; }
        .controls button { padding: 8px 16px; margin: 0 5px; border: none; border-radius: 4px; background: #0066cc; color: white; cursor: pointer; font-size: 14px; }
        .config-panel { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.85); color: #fff; padding: 15px; border-radius: 8px; font-family: Arial, sans-serif; font-size: 13px; z-index: 2000; width: 280px; max-height: 80vh; overflow-y: auto; }
        .config-panel h3 { margin: 0 0 15px 0; font-size: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .config-group { margin-bottom: 15px; }
        .config-group label { display: block; margin-bottom: 5px; color: #aaa; }
        .config-group input[type="range"] { width: 100%; margin-bottom: 3px; }
        .config-group input[type="color"] { width: 50px; height: 28px; border: none; cursor: pointer; }
        .config-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .config-value { display: inline-block; color: #0f0; margin-left: 10px; font-weight: bold; }
        .config-checkbox { display: flex; align-items: center; gap: 8px; }
    </style>
</head>
<body>
    <div id="loading" class="loading">æ­£åœ¨åŠ è½½åœ°çƒ...</div>
    
    <div class="config-panel" id="configPanel">
        <h3>ğŸ“Š æŠ•å½±å‚æ•°é…ç½®</h3>
        
        <div class="config-group">
            <div class="config-row">
                <label>åŠé•¿è½´ (km)</label>
                <span class="config-value" id="valSemiMajor">50</span>
            </div>
            <input type="range" id="semiMajor" min="10" max="200" value="50">
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>åŠçŸ­è½´ (km)</label>
                <span class="config-value" id="valSemiMinor">25</span>
            </div>
            <input type="range" id="semiMinor" min="5" max="100" value="25">
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>å¡«å……é¢œè‰²</label>
                <input type="color" id="fillColor" value="#00ff00">
            </div>
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>å¡«å……é€æ˜åº¦</label>
                <span class="config-value" id="valFillOpacity">60%</span>
            </div>
            <input type="range" id="fillOpacity" min="0" max="100" value="60">
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>è¾¹æ¡†é¢œè‰²</label>
                <input type="color" id="borderColor" value="#00ff00">
            </div>
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>è¾¹æ¡†å®½åº¦</label>
                <span class="config-value" id="valBorderWidth">3</span>
            </div>
            <input type="range" id="borderWidth" min="1" max="10" value="3">
        </div>
        
        <div class="config-group">
            <div class="config-row">
                <label>è¾¹æ¡†é€æ˜åº¦</label>
                <span class="config-value" id="valBorderOpacity">100%</span>
            </div>
            <input type="range" id="borderOpacity" min="0" max="100" value="100">
        </div>
        
        <div class="config-group">
            <label class="config-checkbox">
                <input type="checkbox" id="showFill" checked>
                <span>æ˜¾ç¤ºå¡«å……é¢</span>
            </label>
        </div>
        
        <div class="config-group">
            <label class="config-checkbox">
                <input type="checkbox" id="showBorder" checked>
                <span>æ˜¾ç¤ºè¾¹æ¡†</span>
            </label>
        </div>
        
        <div class="config-group">
            <label class="config-checkbox">
                <input type="checkbox" id="showCone" checked>
                <span>æ˜¾ç¤ºé”¥ä½“ä¾§é¢</span>
            </label>
        </div>
        
        <div class="config-group">
            <label class="config-checkbox">
                <input type="checkbox" id="showOrbit" checked>
                <span>æ˜¾ç¤ºè½¨é“çº¿</span>
            </label>
        </div>
    </div>

    <div class="info">
        <h3>ğŸ›°ï¸ å«æ˜Ÿé”¥ä½“æŠ•å½±</h3>
        <p id="status">çŠ¶æ€: å·²æš‚åœ</p>
        <p>åº•å›¾: <span id="mapName">Bing Maps</span></p>
        <p>ä½ç½®: å››å·ç›†åœ°</p>
        <p style="margin-top: 10px; color: #aaa;">æ“ä½œ: å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</p>
    </div>
    
    <div class="controls">
        <button id="btnReset">ğŸŒ æ˜Ÿä¸‹ç‚¹è§†è§’</button>
        <button id="btnFollow">ğŸ›°ï¸ è·Ÿéšå«æ˜Ÿ</button>
        <button id="btnToggle">â–¶ï¸ æ’­æ”¾</button>
    </div>
    <div id="cesiumContainer"></div>

    <script src="https://cesium.com/downloads/cesiumjs/releases/1.133/Build/Cesium/Cesium.js"></script>
    <script type="module">
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxY2Y3NzY4OC0xMjExLTRiZjUtYTU5Ny1jYzg4ZmUzNzhhZjciLCJpZCI6MjI3NjcsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1ODIwMTQ3MTF9.7nQHPXIiwHNXpRd_cuK_TL8P-27wUKfMt2yvsiWkpyg';

        // ============ é…ç½®å‚æ•° ============
        const config = {
            semiMajor: 50000, semiMinor: 25000,
            fillColor: { r: 0, g: 1, b: 0 }, fillOpacity: 0.6,  // å¢åŠ é€æ˜åº¦ç¡®ä¿å¯è§
            borderColor: { r: 0, g: 1, b: 0 }, borderWidth: 3, borderOpacity: 1.0,  // è¾¹æ¡†ä¸é€æ˜
            showFill: true, showBorder: true, showCone: true, showOrbit: true
        };

        // ============ åˆå§‹åŒ– Viewer ============
        const viewer = new Cesium.Viewer('cesiumContainer', {
            baseLayerPicker: true, geocoder: true, homeButton: true,
            sceneModePicker: true, navigationHelpButton: true, 
            animation: true, timeline: true, fullscreenButton: true
        });

        // è®¾ç½®ä¸–ç•Œåœ°å½¢ï¼ˆæš‚æ—¶ç¦ç”¨ï¼Œä½¿ç”¨å¹³æ»‘åœ°çƒç¡®ä¿æŠ•å½±å¯è§ï¼‰
        // try {
        //     viewer.terrainProvider = await Cesium.createWorldTerrainAsync();
        //     console.log('åœ°å½¢åŠ è½½æˆåŠŸ');
        // } catch(e) {
        //     console.warn('åœ°å½¢åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤åœ°å½¢:', e);
        // }

        // ============ å«æ˜Ÿå‚æ•° ============
        const EARTH_RADIUS = 6371000;
        const ORBIT_HEIGHT = 800000;
        const ORBIT_RADIUS = EARTH_RADIUS + ORBIT_HEIGHT;
        const ORBIT_PERIOD = 90 * 60;
        const INCLINATION = Cesium.Math.toRadians(51.6);
        const NUM_POINTS = 60;
        
        const startTime = Cesium.JulianDate.now();
        const stopTime = Cesium.JulianDate.addSeconds(startTime, 86400, new Cesium.JulianDate());
        
        viewer.clock.startTime = startTime.clone();
        viewer.clock.stopTime = stopTime;
        viewer.clock.currentTime = startTime.clone();
        viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
        viewer.clock.multiplier = 50;
        viewer.clock.shouldAnimate = false;

        // ============ å«æ˜Ÿä½ç½®è®¡ç®— ============
        function getSatellitePosition(time) {
            if (!Cesium.defined(time)) return Cesium.Cartesian3.ZERO;
            const elapsedSeconds = Cesium.JulianDate.secondsDifference(time, startTime);
            const angle = (elapsedSeconds / ORBIT_PERIOD) * 2 * Math.PI;
            const x = ORBIT_RADIUS * Math.cos(angle);
            const y = ORBIT_RADIUS * Math.sin(angle);
            const cosInc = Math.cos(INCLINATION);
            const sinInc = Math.sin(INCLINATION);
            return new Cesium.Cartesian3(x, y * cosInc, y * sinInc);
        }

        // é‡‡æ ·å«æ˜Ÿè½¨é“
        const satellitePositionProperty = new Cesium.SampledPositionProperty();
        satellitePositionProperty.setInterpolationOptions({ 
            interpolationDegree: 5, 
            interpolationAlgorithm: Cesium.LagrangePolynomialApproximation 
        });
        for (let i = 0; i <= 200; i++) {
            const time = Cesium.JulianDate.addSeconds(startTime, (i / 200) * ORBIT_PERIOD, new Cesium.JulianDate());
            satellitePositionProperty.addSample(time, getSatellitePosition(time));
        }

        // ============ å«æ˜Ÿå®ä½“ ============
        const satellite = viewer.entities.add({
            name: 'å«æ˜Ÿ',
            position: satellitePositionProperty,
            availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({ start: startTime, stop: stopTime })]),
            point: { pixelSize: 20, color: Cesium.Color.YELLOW, outlineColor: Cesium.Color.RED, outlineWidth: 3 },
            label: { text: 'ğŸ›°ï¸ å«æ˜Ÿ', font: 'bold 16pt sans-serif', fillColor: Cesium.Color.WHITE, 
                    outlineColor: Cesium.Color.BLACK, outlineWidth: 3, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, 
                    pixelOffset: new Cesium.Cartesian2(0, -25), showBackground: true, 
                    backgroundColor: new Cesium.Color(0, 0, 0, 0.8) }
        });

        // ============ è½¨é“çº¿ ============
        const orbitPoints = [];
        for (let i = 0; i <= 360; i += 2) {
            const angle = Cesium.Math.toRadians(i);
            orbitPoints.push(new Cesium.Cartesian3(
                ORBIT_RADIUS * Math.cos(angle),
                ORBIT_RADIUS * Math.sin(angle) * Math.cos(INCLINATION),
                ORBIT_RADIUS * Math.sin(angle) * Math.sin(INCLINATION)
            ));
        }
        const orbitEntity = viewer.entities.add({
            name: 'è½¨é“çº¿',
            polyline: { positions: orbitPoints, width: 2, material: new Cesium.Color(0, 1, 1, 0.8), arcType: Cesium.ArcType.NONE }
        });

        // ============ è®¡ç®—åœ°é¢æ¤­åœ†ç‚¹ ============
        function computeGroundPoints(satPos, semiMajor, semiMinor) {
            if (!satPos) return [];
            const satCarto = Cesium.Cartographic.fromCartesian(satPos);
            const centerLon = Cesium.Math.toDegrees(satCarto.longitude);
            const centerLat = Cesium.Math.toDegrees(satCarto.latitude);
            const cosLat = Math.cos(Cesium.Math.toRadians(centerLat));
            
            const points = [];
            for (let i = 0; i < NUM_POINTS; i++) {
                const theta = (i / NUM_POINTS) * 2 * Math.PI;
                const dx = semiMajor * Math.cos(theta);
                const dy = semiMinor * Math.sin(theta);
                const deltaLon = Cesium.Math.toDegrees(dx / (EARTH_RADIUS * cosLat));
                const deltaLat = Cesium.Math.toDegrees(dy / EARTH_RADIUS);
                points.push(Cesium.Cartesian3.fromDegrees(centerLon + deltaLon, centerLat + deltaLat, 0));
            }
            return points;
        }

        // ============ æŠ•å½±å®ä½“ ============
        let groundFillEntity, groundBorderEntity, coneEntities = [];

        function createOrUpdateProjection() {
            if (groundFillEntity) viewer.entities.remove(groundFillEntity);
            if (groundBorderEntity) viewer.entities.remove(groundBorderEntity);
            coneEntities.forEach(e => viewer.entities.remove(e));
            coneEntities = [];

            const currentTime = viewer.clock.currentTime;
            const satPos = satellitePositionProperty.getValue(currentTime);
            if (!satPos) {
                console.warn('å«æ˜Ÿä½ç½®æ— æ•ˆ');
                return;
            }

            const groundPoints = computeGroundPoints(satPos, config.semiMajor, config.semiMinor);
            if (groundPoints.length === 0) {
                console.warn('åœ°é¢ç‚¹è®¡ç®—å¤±è´¥');
                return;
            }
            
            console.log('åˆ›å»ºæŠ•å½±ï¼Œåœ°é¢ç‚¹æ•°:', groundPoints.length, 'æ˜¾ç¤ºå¡«å……:', config.showFill, 'æ˜¾ç¤ºè¾¹æ¡†:', config.showBorder);

            // åœ°é¢å¡«å……é¢
            if (config.showFill) {
                groundFillEntity = viewer.entities.add({
                    name: 'åœ°é¢æŠ•å½±é¢',
                    polygon: {
                        hierarchy: new Cesium.PolygonHierarchy(groundPoints),
                        material: new Cesium.Color(config.fillColor.r, config.fillColor.g, config.fillColor.b, config.fillOpacity),
                        outline: false
                        // ä¸ä½¿ç”¨ classificationTypeï¼Œè®©å¤šè¾¹å½¢æ­£å¸¸æ˜¾ç¤ºåœ¨åœ°çƒè¡¨é¢
                    }
                });
            }

            // åœ°é¢è¾¹æ¡†
            if (config.showBorder) {
                const borderPositions = [...groundPoints, groundPoints[0]];
                groundBorderEntity = viewer.entities.add({
                    name: 'åœ°é¢æŠ•å½±è¾¹æ¡†',
                    polyline: {
                        positions: borderPositions,
                        width: config.borderWidth,
                        material: new Cesium.Color(config.borderColor.r, config.borderColor.g, config.borderColor.b, config.borderOpacity),
                        arcType: Cesium.ArcType.GEODESIC,
                        clampToGround: true
                    }
                });
            }

            // é”¥ä½“ä¾§é¢
            if (config.showCone) {
                for (let i = 0; i < NUM_POINTS; i += 3) {
                    const next = (i + 3) % NUM_POINTS;
                    coneEntities.push(viewer.entities.add({
                        name: 'é”¥ä½“ä¾§é¢_' + i,
                        polygon: {
                            hierarchy: new Cesium.PolygonHierarchy([satPos, groundPoints[i], groundPoints[next]]),
                            material: new Cesium.Color(config.fillColor.r, config.fillColor.g, config.fillColor.b, config.fillOpacity * 0.5),
                            outline: false,
                            perPositionHeight: true
                        }
                    }));
                }
            }
        }

        createOrUpdateProjection();
        console.log('åˆå§‹æŠ•å½±å·²åˆ›å»º');

        viewer.scene.preUpdate.addEventListener(function() {
            if (viewer.clock.shouldAnimate) {
                createOrUpdateProjection();
            }
        });

        // ============ é…ç½®é¢æ¿åŠŸèƒ½ ============
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 0, g: 1, b: 0 };
        }

        function updateConfig() {
            config.semiMajor = parseInt(document.getElementById('semiMajor').value) * 1000;
            config.semiMinor = parseInt(document.getElementById('semiMinor').value) * 1000;
            config.fillColor = hexToRgb(document.getElementById('fillColor').value);
            config.fillOpacity = parseInt(document.getElementById('fillOpacity').value) / 100;
            config.borderColor = hexToRgb(document.getElementById('borderColor').value);
            config.borderWidth = parseInt(document.getElementById('borderWidth').value);
            config.borderOpacity = parseInt(document.getElementById('borderOpacity').value) / 100;
            config.showFill = document.getElementById('showFill').checked;
            config.showBorder = document.getElementById('showBorder').checked;
            config.showCone = document.getElementById('showCone').checked;
            config.showOrbit = document.getElementById('showOrbit').checked;

            document.getElementById('valSemiMajor').textContent = document.getElementById('semiMajor').value;
            document.getElementById('valSemiMinor').textContent = document.getElementById('semiMinor').value;
            document.getElementById('valFillOpacity').textContent = document.getElementById('fillOpacity').value + '%';
            document.getElementById('valBorderWidth').textContent = config.borderWidth;
            document.getElementById('valBorderOpacity').textContent = document.getElementById('borderOpacity').value + '%';

            orbitEntity.show = config.showOrbit;
            createOrUpdateProjection();
        }

        // ç»‘å®šé…ç½®é¢æ¿äº‹ä»¶
        document.querySelectorAll('#configPanel input').forEach(input => {
            input.addEventListener('input', updateConfig);
            input.addEventListener('change', updateConfig);
        });

        // ============ åˆå§‹ä½ç½®ï¼šå››å·ä¸Šç©º ============
        const CHINA_LON = 104.0;
        const CHINA_LAT = 30.0;
        const initialAngle = Cesium.Math.toRadians(CHINA_LON);
        const initialTime = Cesium.JulianDate.addSeconds(startTime, (initialAngle / (2 * Math.PI)) * ORBIT_PERIOD, new Cesium.JulianDate());
        viewer.clock.currentTime = initialTime.clone();

        const initialSatPos = satellitePositionProperty.getValue(initialTime);
        const initialCarto = Cesium.Cartographic.fromCartesian(initialSatPos);
        const initialLon = Cesium.Math.toDegrees(initialCarto.longitude);
        const initialLat = Cesium.Math.toDegrees(initialCarto.latitude);
        
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(initialLon, initialLat, 150000),
            orientation: { heading: 0, pitch: Cesium.Math.toRadians(-90), roll: 0 }
        });

        // ============ æ§åˆ¶å‡½æ•° ============
        let isFollowing = false, isPlaying = false;
        
        document.getElementById('btnReset').addEventListener('click', () => {
            viewer.trackedEntity = undefined;
            isFollowing = false;
            const currentTime = viewer.clock.currentTime;
            const satPos = satellitePositionProperty.getValue(currentTime);
            const carto = Cesium.Cartographic.fromCartesian(satPos);
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude), 150000),
                orientation: { heading: 0, pitch: Cesium.Math.toRadians(-90), roll: 0 }
            });
        });
        
        document.getElementById('btnFollow').addEventListener('click', () => {
            isFollowing = !isFollowing;
            viewer.trackedEntity = isFollowing ? satellite : undefined;
            document.getElementById('status').textContent = isFollowing ? 'çŠ¶æ€: è·Ÿéšå«æ˜Ÿ' : (isPlaying ? 'çŠ¶æ€: æ’­æ”¾ä¸­' : 'çŠ¶æ€: å·²æš‚åœ');
        });
        
        document.getElementById('btnToggle').addEventListener('click', () => {
            isPlaying = !isPlaying;
            viewer.clock.shouldAnimate = isPlaying;
            document.getElementById('status').textContent = isPlaying ? 'çŠ¶æ€: æ’­æ”¾ä¸­' : 'çŠ¶æ€: å·²æš‚åœ';
            document.getElementById('btnToggle').textContent = isPlaying ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾';
        });

        document.getElementById('loading').style.display = 'none';
        console.log('âœ… Cesium 1.133 å«æ˜Ÿé”¥ä½“æŠ•å½±å·²å¯åŠ¨');
    </script>
</body>
</html>
