<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cesium Earth with Satellite</title>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body, #cesiumContainer { width: 100%; height: 100%; overflow: hidden; }
        .loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: Arial; font-size: 18px; color: #fff; z-index: 1000; background: rgba(0, 0, 0, 0.7); padding: 20px 40px; border-radius: 8px; }
        .info { position: absolute; top: 10px; left: 10px; background: rgba(0, 0, 0, 0.7); color: #fff; padding: 15px; border-radius: 8px; font-family: Arial; font-size: 14px; z-index: 1000; max-width: 320px; }
        .controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.7); padding: 10px 20px; border-radius: 8px; z-index: 1000; }
        .controls button { padding: 8px 16px; margin: 0 5px; border: none; border-radius: 4px; background: #0066cc; color: white; cursor: pointer; font-size: 14px; }
        .map-selector { position: absolute; bottom: 80px; right: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 8px; z-index: 2000; }
        .map-selector select { padding: 8px; font-size: 14px; border-radius: 4px; border: none; background: #fff; cursor: pointer; }
    </style>
</head>
<body>
    <div id="loading" class="loading">æ­£åœ¨åŠ è½½åœ°çƒ...</div>
    <div class="info">
        <h3>ğŸ›°ï¸ å«æ˜Ÿé”¥ä½“æŠ•å½±</h3>
        <p id="status">çŠ¶æ€: å·²æš‚åœ</p>
        <p>åº•å›¾: <span id="mapName">ESRI å«æ˜Ÿ</span></p>
        <p>ä½ç½®: å››å·ç›†åœ°ï¼ˆæœ‰å±±åœ°åŒºï¼‰</p>
        <p>è½¨é“é«˜åº¦: ~800km | æ¤­åœ†: 100Ã—50km</p>
        <p style="margin-top: 10px; color: #aaa;">æ“ä½œ: å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</p>
    </div>
    <div class="map-selector">
        <select id="mapSelect">
            <option value="satellite" selected>ESRI å«æ˜Ÿ</option>
            <option value="darkMatter">Dark Matter</option>
            <option value="osm">OpenStreetMap</option>
            <option value="cartoLight">CartoDB æµ…è‰²</option>
        </select>
    </div>
    <div class="controls">
        <button id="btnReset">ğŸŒ å…¨çƒè§†è§’</button>
        <button id="btnFollow">ğŸ›°ï¸ è·Ÿéšå«æ˜Ÿ</button>
        <button id="btnToggle">â–¶ï¸ æ’­æ”¾</button>
    </div>
    <div id="cesiumContainer"></div>

    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <script>
        // è®¾ç½®token
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIxY2Y3NzY4OC0xMjExLTRiZjUtYTU5Ny1jYzg4ZmUzNzhhZjciLCJpZCI6MjI3NjcsInNjb3BlcyI6WyJhc3IiLCJnYyJdLCJpYXQiOjE1ODIwMTQ3MTF9.7nQHPXIiwHNXpRd_cuK_TL8P-27wUKfMt2yvsiWkpyg';

        // ============ åº•å›¾é…ç½® ============
        const mapProviders = {
            osm: { name: 'OpenStreetMap', provider: new Cesium.UrlTemplateImageryProvider({ url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', subdomains: ['a', 'b', 'c'] }) },
            cartoLight: { name: 'CartoDB æµ…è‰²', provider: new Cesium.UrlTemplateImageryProvider({ url: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', subdomains: ['a', 'b', 'c', 'd'] }) },
            darkMatter: { name: 'Dark Matter', provider: new Cesium.UrlTemplateImageryProvider({ url: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', subdomains: ['a', 'b', 'c', 'd'] }) },
            satellite: { name: 'ESRI å«æ˜Ÿ', provider: new Cesium.UrlTemplateImageryProvider({ url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}' }) }
        };

        // ============ åˆå§‹åŒ– Viewerï¼ˆå¯ç”¨åœ°å½¢ï¼‰============
        // ä½¿ç”¨ Cesium Ion çš„ä¸–ç•Œåœ°å½¢èµ„æº
        const terrainProvider = new Cesium.CesiumTerrainProvider({
            url: Cesium.IonResource.fromAssetId(1), // Cesium World Terrain asset ID
            requestVertexNormals: true,
            requestWaterMask: true
        });
        
        const viewer = new Cesium.Viewer('cesiumContainer', {
            imageryProvider: true,
            // terrainProvider: terrainProvider,
            baseLayerPicker: true, geocoder: true, homeButton: true,
            sceneModePicker: true, navigationHelpButton: true, animation: true, timeline: true, fullscreenButton: true
        });

        // å¯ç”¨å…‰ç…§æ•ˆæœï¼ˆåœ°å½¢ç«‹ä½“æ„Ÿæ›´å¼ºï¼‰
        viewer.scene.globe.enableLighting = true;

        function switchMap(mapKey) {
            const mapConfig = mapProviders[mapKey];
            if (!mapConfig) return;
            viewer.imageryLayers.removeAll();
            viewer.imageryLayers.addImageryProvider(mapConfig.provider);
            document.getElementById('mapName').textContent = mapConfig.name;
            document.getElementById('mapSelect').value = mapKey;
        }
        setTimeout(() => { switchMap('satellite'); document.getElementById('loading').style.display = 'none'; }, 100);
        document.getElementById('mapSelect').addEventListener('change', (e) => switchMap(e.target.value));

        // ============ å«æ˜Ÿå‚æ•° ============
        const EARTH_RADIUS = 6371000;
        const ORBIT_HEIGHT = 800000;
        const ORBIT_RADIUS = EARTH_RADIUS + ORBIT_HEIGHT;
        const ORBIT_PERIOD = 90 * 60;
        const INCLINATION = Cesium.Math.toRadians(51.6);
        
        // ç¼©å°æ¤­åœ†ï¼š100km Ã— 50km
        const COVERAGE_SEMI_MAJOR = 50000; // 50km
        const COVERAGE_SEMI_MINOR = 25000; // 25km
        const NUM_POINTS = 60;
        
        // ============ æ—¶é’Ÿè®¾ç½®ï¼ˆé»˜è®¤æš‚åœï¼‰============
        const startTime = Cesium.JulianDate.now();
        const stopTime = Cesium.JulianDate.addSeconds(startTime, 86400, new Cesium.JulianDate());
        
        viewer.clock.startTime = startTime.clone();
        viewer.clock.stopTime = stopTime;
        viewer.clock.currentTime = startTime.clone();
        viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP;
        viewer.clock.multiplier = 50;
        viewer.clock.shouldAnimate = false; // é»˜è®¤æš‚åœ

        // ============ å«æ˜Ÿä½ç½®è®¡ç®— ============
        function getSatellitePosition(time) {
            if (!Cesium.defined(time)) return Cesium.Cartesian3.ZERO;
            const elapsedSeconds = Cesium.JulianDate.secondsDifference(time, startTime);
            const angle = (elapsedSeconds / ORBIT_PERIOD) * 2 * Math.PI;
            const x = ORBIT_RADIUS * Math.cos(angle);
            const y = ORBIT_RADIUS * Math.sin(angle);
            const cosInc = Math.cos(INCLINATION);
            const sinInc = Math.sin(INCLINATION);
            return new Cesium.Cartesian3(x, y * cosInc, y * sinInc);
        }

        // ============ é‡‡æ ·å«æ˜Ÿè½¨é“ ============
        const satellitePositionProperty = new Cesium.SampledPositionProperty();
        satellitePositionProperty.setInterpolationOptions({ interpolationDegree: 5, interpolationAlgorithm: Cesium.LagrangePolynomialApproximation });
        for (let i = 0; i <= 200; i++) {
            const time = Cesium.JulianDate.addSeconds(startTime, (i / 200) * ORBIT_PERIOD, new Cesium.JulianDate());
            satellitePositionProperty.addSample(time, getSatellitePosition(time));
        }

        // ============ å«æ˜Ÿå®ä½“ ============
        const satellite = viewer.entities.add({
            name: 'å«æ˜Ÿ',
            position: satellitePositionProperty,
            availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({ start: startTime, stop: stopTime })]),
            point: { pixelSize: 20, color: Cesium.Color.YELLOW, outlineColor: Cesium.Color.RED, outlineWidth: 3 },
            label: { text: 'ğŸ›°ï¸ å«æ˜Ÿ', font: 'bold 16pt sans-serif', fillColor: Cesium.Color.WHITE, outlineColor: Cesium.Color.BLACK, outlineWidth: 3, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, pixelOffset: new Cesium.Cartesian2(0, -25), showBackground: true, backgroundColor: new Cesium.Color(0, 0, 0, 0.8) }
        });

        // ============ è½¨é“çº¿ ============
        const orbitPoints = [];
        for (let i = 0; i <= 360; i += 2) {
            const angle = Cesium.Math.toRadians(i);
            orbitPoints.push(new Cesium.Cartesian3(
                ORBIT_RADIUS * Math.cos(angle),
                ORBIT_RADIUS * Math.sin(angle) * Math.cos(INCLINATION),
                ORBIT_RADIUS * Math.sin(angle) * Math.sin(INCLINATION)
            ));
        }
        viewer.entities.add({ name: 'è½¨é“çº¿', polyline: { positions: orbitPoints, width: 2, material: new Cesium.Color(0, 1, 1, 0.8), arcType: Cesium.ArcType.NONE } });

        // ============ è®¡ç®—åœ°é¢æ¤­åœ†ç‚¹çš„å‡½æ•° ============
        function computeGroundPoints(satPos) {
            if (!satPos) return [];
            const satCarto = Cesium.Cartographic.fromCartesian(satPos);
            const centerLon = Cesium.Math.toDegrees(satCarto.longitude);
            const centerLat = Cesium.Math.toDegrees(satCarto.latitude);
            const cosLat = Math.cos(Cesium.Math.toRadians(centerLat));
            
            const points = [];
            for (let i = 0; i < NUM_POINTS; i++) {
                const theta = (i / NUM_POINTS) * 2 * Math.PI;
                const dx = COVERAGE_SEMI_MAJOR * Math.cos(theta);
                const dy = COVERAGE_SEMI_MINOR * Math.sin(theta);
                const deltaLon = Cesium.Math.toDegrees(dx / (EARTH_RADIUS * cosLat));
                const deltaLat = Cesium.Math.toDegrees(dy / EARTH_RADIUS);
                // é«˜åº¦è®¾ä¸º0ï¼Œè®©Cesiumæ ¹æ®åœ°å½¢è‡ªåŠ¨è®¡ç®—
                points.push(Cesium.Cartesian3.fromDegrees(centerLon + deltaLon, centerLat + deltaLat, 0));
            }
            return points;
        }

        // ============ é”¥ä½“æŠ•å½± ============
        
        // 1. åœ°é¢æ¤­åœ†è¾¹ç•Œçº¿
        const groundBoundaryEntity = viewer.entities.add({
            name: 'åœ°é¢æ¤­åœ†è¾¹ç•Œ',
            polyline: {
                positions: new Cesium.CallbackProperty(function(time) {
                    const satPos = satellitePositionProperty.getValue(time);
                    const points = computeGroundPoints(satPos);
                    if (points.length === 0) return [];
                    return [...points, points[0]];
                }, false),
                width: 3,
                material: new Cesium.Color(1, 1, 0, 0.9),
                arcType: Cesium.ArcType.GEODESIC
            }
        });

        // 2. åœ°é¢å¡«å……é¢ï¼ˆç»¿è‰²é€æ˜ï¼Œè´´åœ°å½¢æ˜¾ç¤ºï¼‰
        const groundFillEntity = viewer.entities.add({
            name: 'åœ°é¢æŠ•å½±é¢',
            polygon: {
                hierarchy: new Cesium.CallbackProperty(function(time) {
                    const satPos = satellitePositionProperty.getValue(time);
                    const points = computeGroundPoints(satPos);
                    return new Cesium.PolygonHierarchy(points);
                }, false),
                material: new Cesium.Color(0, 1, 0, 0.35), // ç»¿è‰²ï¼Œ35%é€æ˜åº¦
                outline: false,
                // ä½¿ç”¨ classificationType è®©å¤šè¾¹å½¢è´´åœ°å½¢æ˜¾ç¤º
                classificationType: Cesium.ClassificationType.TERRAIN
            }
        });

        // 3. é”¥ä½“ä¾§é¢å¡«å……ï¼ˆä½¿ç”¨20ä¸ªä¸‰è§’å½¢æ‰‡åŒºè¿‘ä¼¼ï¼‰
        for (let i = 0; i < NUM_POINTS; i += 3) {
            const next = (i + 3) % NUM_POINTS;
            viewer.entities.add({
                name: 'é”¥ä½“ä¾§é¢_' + i,
                polygon: {
                    hierarchy: new Cesium.CallbackProperty((function(idx1, idx2) {
                        return function(time) {
                            const satPos = satellitePositionProperty.getValue(time);
                            if (!satPos) return [];
                            const points = computeGroundPoints(satPos);
                            if (points.length === 0) return [];
                            return new Cesium.PolygonHierarchy([satPos, points[idx1], points[idx2]]);
                        };
                    })(i, next), false),
                    material: new Cesium.Color(1, 0.5, 0, 0.15),
                    outline: false,
                    perPositionHeight: true
                }
            });
        }

        // ============ è®¾ç½®åˆå§‹ä½ç½®ï¼šä¸­å›½å››å·ï¼ˆæœ‰å±±åœ°åŒºï¼‰============
        // å››å·ç›†åœ°é™„è¿‘ï¼Œç»åº¦çº¦ 104Â°Eï¼Œçº¬åº¦çº¦ 30Â°Nï¼Œå‘¨å›´æœ‰å±±
        const CHINA_LON = 104.0;
        const CHINA_LAT = 30.0;
        
        // è®¡ç®—å«æ˜Ÿåœ¨è¯¥ä½ç½®ä¸Šç©ºçš„åˆå§‹æ—¶é—´
        // å°†ç»çº¬åº¦è½¬æ¢ä¸ºè½¨é“è§’åº¦ï¼ˆç®€åŒ–è®¡ç®—ï¼‰
        const initialAngle = Cesium.Math.toRadians(CHINA_LON);
        const initialTime = Cesium.JulianDate.addSeconds(startTime, (initialAngle / (2 * Math.PI)) * ORBIT_PERIOD, new Cesium.JulianDate());
        
        // è®¾ç½®æ—¶é’Ÿåˆ°è¯¥æ—¶é—´
        viewer.clock.currentTime = initialTime.clone();
        
        // ============ åˆå§‹è§†è§’ï¼šè®¾åœ¨æ˜Ÿä¸‹ç‚¹ï¼ˆä¿¯è§†åœ°é¢æŠ•å½±ï¼‰============
        const initialSatPos = satellitePositionProperty.getValue(initialTime);
        const initialCarto = Cesium.Cartographic.fromCartesian(initialSatPos);
        const initialLon = Cesium.Math.toDegrees(initialCarto.longitude);
        const initialLat = Cesium.Math.toDegrees(initialCarto.latitude);
        
        // ç›¸æœºä½ç½®ï¼šæ˜Ÿä¸‹ç‚¹æ­£ä¸Šæ–¹ï¼Œé«˜åº¦çº¦ 150km
        viewer.camera.setView({
            destination: Cesium.Cartesian3.fromDegrees(initialLon, initialLat, 150000),
            orientation: { 
                heading: 0, 
                pitch: Cesium.Math.toRadians(-90), // æ­£ä¿¯è§†
                roll: 0 
            }
        });

        // ============ æ§åˆ¶å‡½æ•° ============
        let isFollowing = false;
        let isPlaying = false; // é»˜è®¤æš‚åœ
        
        function resetView() {
            viewer.trackedEntity = undefined;
            isFollowing = false;
            const currentTime = viewer.clock.currentTime;
            const satPos = satellitePositionProperty.getValue(currentTime);
            const carto = Cesium.Cartographic.fromCartesian(satPos);
            const lon = Cesium.Math.toDegrees(carto.longitude);
            const lat = Cesium.Math.toDegrees(carto.latitude);
            
            // å›åˆ°æ˜Ÿä¸‹ç‚¹æ­£ä¸Šæ–¹
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(lon, lat, 150000),
                orientation: { heading: 0, pitch: Cesium.Math.toRadians(-90), roll: 0 }
            });
        }
        
        function followSatellite() {
            isFollowing = !isFollowing;
            viewer.trackedEntity = isFollowing ? satellite : undefined;
            document.getElementById('status').textContent = isFollowing ? 'çŠ¶æ€: è·Ÿéšå«æ˜Ÿ' : (isPlaying ? 'çŠ¶æ€: æ’­æ”¾ä¸­' : 'çŠ¶æ€: å·²æš‚åœ');
        }
        
        function toggleAnimation() {
            isPlaying = !isPlaying;
            viewer.clock.shouldAnimate = isPlaying;
            document.getElementById('status').textContent = isPlaying ? 'çŠ¶æ€: æ’­æ”¾ä¸­' : 'çŠ¶æ€: å·²æš‚åœ';
            document.getElementById('btnToggle').textContent = isPlaying ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾';
        }

        document.getElementById('btnReset').addEventListener('click', resetView);
        document.getElementById('btnFollow').addEventListener('click', followSatellite);
        document.getElementById('btnToggle').addEventListener('click', toggleAnimation);

        console.log('âœ… å«æ˜Ÿé”¥ä½“æŠ•å½±å·²å¯åŠ¨ - ä½ç½®ï¼šå››å·ç›†åœ°');
        console.log('åœ°å½¢å·²å¯ç”¨ï¼Œå¯çœ‹åˆ°å±±è„‰æ•ˆæœ');
    </script>
</body>
</html>
